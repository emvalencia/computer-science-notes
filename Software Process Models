Software Process Models
-------------------------
Models:
I.    Build-and-Fix
II.   Waterfall
III.  Rapid Prototyping
IV.   Incremental 
V.    Spiral
VI.   Rational Unified Process (RUP)
VII.  Open Source Software (OSS)
VIII. Extreme Programming (XP)
IX.   Agile 

Remember: The 3 essential ingredients of software engineering are:
  1) People
  2) Processes
  3) Tools 
  
Difficulties of software engineering (SE):
  - Essential qualities: complexity, conformity, changeability, intangibility 
  - Those essential qualities can lead to drastic/disasterous consequences 
  
Processes: 
  - Elements: phases, products, roles, resources
  - Relationships between elements: precedence, requires this or that, provides this or that...  
  - Constraints: time, cost, qualities 
 
Models:
 - A model is a simplified representation of something 
 - Prescriptive models enforce rules
 - Descriptive models describe or characterize
 
Software Risks (per Boehm): risk/management techniques
  - Personnel shortfalls -> get staff with top talent, job matching, morale building
  - Unrealistic schedules and budgets -> detailed cost/schedule estimation, reuse, incremental development
  - Developing the wrong software functions -> user surverys, prototyping
  - Continuing stream of software changes -> information hiding, incremental development
  - Shortfalls in externally furnished components -> compatibility analysis
  - Shortfalls in externally performed tasks -> reference checking, competitive design or prototyping 
  
I. Build-and-Fix 
   - Steps: build 1st version, modify until client is satisfied (repeat), operations mode (maintenance with prior step), 
      retirement
   - Strengths: good for small programs that don't require much maintenance or many devs
   - Weaknesses: not rigorous enough for larger projects 

II. Waterfall
   - Steps: requirements phase -> design phase -> implementation phase -> integration phase -> testing phase -> 
      operations mode (repeat prior steps but the 1st for maintenance) -> retirement 
   - Strengths: promotes understanding of requirements, disciplined/rigorous/formal, lots of documentation, easy to track
      progress, good for shorter, simpler projects with well-understood requirements, provided a starting point for other 
      software process models 
   - Weaknesses: rigid/hard to change, limited user input, bad for long-term projects with ambiguity in requirements

III. Rapid Prototyping 
   - Steps: build and discard simple prototype -> design phase -> implementation phase -> integration phase -> testing 
      phase -> operations mode (repeat prior steps but the 1st for maintenance) -> retirement 
      ***Notice that the only difference between this and the Waterall Process is the "build and discard simple prototype"
   - Strengths: reduced time and costs, improved and increased user involvement (1) 
   - Weaknesses: insufficient analysis, user confusion of prototype and finished system, developer misunderstanding of user
      objectives, developer attachment to prototype, excessive development time of the prototype, expense of implementing 
      prototype (1)
      
IV. Incremental 
    - Steps: requirements phase (then verify) -> architectural design (then verify) -> for each increment: perform detailed
      design, implementation, and integration, test, deliver to client -> operations mode (maintenance of prior steps) ->
      retirement  
      
V. Spiral 
    - Steps: risk analysis (RA) -> rapid prototype -> verify (V) -> RA -> design -> V -> RA -> implementation -> V 
    - Strengths: good for new projects with uncertain, complex requirements
    - Weaknesses: developers have to be competent at risk analysis
    
VI. Rational Unified Process (RUP)
    - A use-case driven model that is architecture centric and iterative/incremental
    - Iterate through phases: inception, elaboration, construction, and transition 
    - Consists of workflows:
      1. Process: business modeling, requirements, analysis and design, implementation, test, deployment
      2. Configuration management, management, environment 
    - Workflows grup activities logically
    - In an iteration you walk through all workflows
    - Strengths: risk-driven/incremental, lots of tool support/guidance
    - Weaknesses: complicated (need a process expert)

VII.1 Open-Source Software (OSS): Classic Version 
    - Source code is freely available and re-distributable 
    - Philosophy: "This is a way to optimize the usage of the work, the value of humanity as a whole gets from it. At 
      the cost, of course, of the ability of the producer to capture value." - Marijn Haverbeke 
    - Strengths: many contributors working in a distributed manner (also volunteers), scales well 
    - Weaknesses: heavy reliance on software tools (web, email, version control, repositories...)
    - Two phases:
      1. Develop initial version- usually 1 or small # of developers
      2. Maintain (evolve)- corrective maintenance, perfective maintenance, adaptive maintenance
    - Ex. Linux, Firefox, MySQL, Eclipse, Apache, gcc compiler...

VII.2 Open-Source: The Corporate Version
    - Pros: saves money, avoids "lock-in", provides "business agility"
    - Companies sponsor open source projects: provide funding, developer resources, infrastructure, management
    - Ex. Android, Alliance for Open Media (Microsoft, Google, Cisco, Intel, Amazon, Netflix, Mozilla) 
    - Strengths: accessibility, huge user base, novel features, higher quality code, great minds motivated and working
      together to solve problems leads to advancements
    - Weaknesses: not appropriate for proprietary software, software with strict requirements and/or tight deadlines, 
      technical support/maintenance can by iffy, developers are often not compensated financially 
 
VIII. Extreme Programming (XP) 
    - Practices and principles: whole team, planning game, small releases, customer tests, simple design, pair
      programming, test-driven development, design improvement, continuous integration, collective code ownership, 
      coding standards, metaphor, sustainable pace/developer welfare, open space, shared understanding, praid and fine
      feedback, continuous process
    - Steps: determine desired features, implement/deliver each task, follow values and principles
    
IX: Agile 
  
  
 
@copy: Most notes are property of Professor Ziv and Navarro at UCI
1. https://www.iotap.com/blog/entryid/124/advantages-disadvantage-of-prototyping-process-model
